<!doctype html>
<html lang="en-GB"><head><meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">

	<link rel="icon" type="image/png" href="../favicon.png">

	<title>Two-way binding | Docs | Ractive.js</title>

	
	<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro:400,700,900" rel="stylesheet" type="text/css">
	<link rel="stylesheet" href="../min.css"></head>

<body class="example"><header class="docs-header"><nav><a href=http://ractivejs.org>&laquo; back to ractivejs.org</a></nav>

		<h1>Two-way binding</h1></header>

	<main><div class="breadcrumbs"><a href="ractive-js-documentation">Home</a> &raquo; <a href="glossary">Glossary</a> &raquo; <a href="two-way-binding">Two‚Äêway binding</a></div>

<p>By default, a Ractive instance will update its internal model based on user input, if you have <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>&lt;select&gt;</code> elements.</p>
<p>If that&#39;s unhelpful for your app, you can disable it by passing <code>twoway: false</code> as an <a href="Initialisation-options">initialisation option</a>.</p>
<h2 id="-input-elements"><code>&lt;input&gt;</code> elements</h2>
<p>Two-way binding works with <code>&lt;input&gt;</code> elements of any type, including the new HTML5 types such as <code>color</code> or <code>email</code>. In most cases, you just add a mustache as the <code>value</code> attribute &ndash; this must be a single, standard <em>interpolator</em> mustache, like this:</p>
<pre class="prettyprint lang-html">&lt;input placeholder='Type your name' value='{{user.name}}'&gt;</pre>

<p>In the example above, any changes the user makes to the input will be reflected in the <code>user.name</code> property.</p>
<h3 id="checkboxes">Checkboxes</h3>
<p>Checkboxes are used to flag a property as <code>true</code> or <code>false</code>. Rather than binding the <code>value</code> attribute, we bind the <code>checked</code> attribute:</p>
<pre class="prettyprint lang-html">&lt;label&gt;
  &lt;input type='checkbox' checked='{{on}}'&gt;
  The lights are {{ on ? 'on' : 'off' }}
&lt;/label&gt;</pre>

<p>(True HTML nerds will recognise that <em>boolean attributes</em> such as checked don&#39;t have a value, as such &ndash; they either exist on an element or they don&#39;t. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is <code>true</code>, absent if <code>false</code>.)</p>
<h3 id="radios">Radios</h3>
<p>Radio buttons can be controlled in the same way as checkboxes. However the chances are, if you&#39;re using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the <code>name</code> attribute on a radio input to e.g. <code>{{someValue}}</code>, <code>someValue</code> will reflect the <code>value</code> of the currently checked option:</p>
<pre class="prettyprint lang-html">&lt;label&gt;&lt;input type='radio' name='{{color}}' value='red' checked&gt; Red&lt;/label&gt;
&lt;label&gt;&lt;input type='radio' name='{{color}}' value='green'&gt; Green&lt;/label&gt;
&lt;label&gt;&lt;input type='radio' name='{{color}}' value='blue'&gt; Blue&lt;/label&gt;

&lt;p&gt;The currently selected color is &lt;span style='color: {{color}};'&gt;{{color}}&lt;/span&gt;&lt;/p&gt;</pre>

<p>In the example above, the value of <code>color</code> will initially be <code>&#39;red&#39;</code> (because that input is checked in the template), and will update as and when the user selects another option.</p>
<h2 id="-textarea-elements"><code>&lt;textarea&gt;</code> elements</h2>
<p>Textareas work exactly the same as standard text inputs &ndash; slap a dynamic <code>value</code> attribute on them, and you&#39;re done:</p>
<pre class="prettyprint lang-html">&lt;textarea value='{{content}}'&gt;&lt;/textarea&gt;</pre>


<h2 id="-select-elements"><code>&lt;select&gt;</code> elements</h2>
<p>Drop-down select menus are good when you have many options to choose from. They&#39;re straightforward to use in Ractive:</p>
<pre class="prettyprint lang-html">&lt;select value='{{selectedCountry}}'&gt;
  &lt;option selected disabled&gt;Select a country&lt;/option&gt;
  {{#countries}}
    &lt;option value='{{id}}'&gt;{{name}}&lt;/option&gt;
  {{/countries}}
&lt;/select&gt;</pre>

<pre class="prettyprint lang-js">ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: {
    countries: [
      { id: 'AFG', name: 'Afghanistan' },
      { id: 'ALB', name: 'Albania' },
      { id: 'DZA', name: 'Algeria' },
      { id: 'ASM', name: 'American Samoa' }
      // and so on...
    ]
  }
});</pre>

<p>In the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of <code>selectedCountry</code> would change to <code>&#39;AFG&#39;</code>.</p>
<h2 id="ambiguous-references">Ambiguous references</h2>
<p>A mustache used in a two-way binding context must have an <em>unambiguous reference</em>. Consider the following:</p>
<pre class="prettyprint lang-html">{{#foo}}
  &lt;input value='{{bar}}'&gt;
{{/foo}}</pre>

<pre class="prettyprint lang-js">ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: { foo: {} }
});</pre>

<p>Ractive must decide, straight away, what <a href="keypaths">keypath</a> to bind the input&#39;s <code>value</code> attribute to. It will first see if it can <a href="references">resolve the reference</a> (<code>&#39;bar&#39;</code>) given the current context stack (which includes a single context &ndash; <code>&#39;foo&#39;</code>). It can&#39;t, so it is forced to make an assumption &ndash; that the <code>&#39;bar&#39;</code> reference should resolve to the <code>&#39;bar&#39;</code> keypath.</p>
<p>But this might not be what you want &ndash; maybe you <em>did</em> want it to resolve to <code>&#39;foo.bar&#39;</code>.</p>
<p>You have two options &ndash; either use a <a href="mustaches#restricted-references">restricted reference</a>, i.e. <code>&lt;input value=&#39;{{.bar}}&#39;&gt;</code>, or ensure that <code>foo</code> has a <code>bar</code> property (even if the initial value is <code>undefined</code>).</p>
<h2 id="lazy-updates">Lazy updates</h2>
<p>Under the hood, Ractive always binds to the <code>change</code> event (and the <code>click</code> event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the <code>input</code> event, which means the model is updated instantly when the user enters data (the <code>change</code> event fires when a change is <a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events/change">&#39;committed by the user&#39;</a>). In some situations, that&#39;s not what you want &ndash; if you want to only bind to <code>change</code>, pass in <code>lazy: true</code> as an <a href="initialisation-options">initialisation option</a>.</p>
<h2 id="observing-changes">Observing changes</h2>
<p>To use user input elsewhere in your app, you&#39;ll need to observe it using <a href="ractive-observe">ractive.observe()</a>:</p>
<pre class="prettyprint lang-html">&lt;input placeholder='Type your name' value='{{user.name}}'&gt;</pre>

<pre class="prettyprint lang-js">ractive = new Ractive({
  el: myContainer,
  template: myTemplate
});

ractive.observe( 'user.name', function ( newValue ) {
  app.user.name = newValue;
  triggerSomeBehaviour();
});</pre></main>

	
	<script src="../js/prettify.js"></script>
	<script>prettyPrint();

		// Googlytics
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-5602942-6', 'ractivejs.org');
		ga('send', 'pageview');</script></body></html>